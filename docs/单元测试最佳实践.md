# 单元测试最佳实践指南

## 一、测试框架和工具

### 1. 核心框架
- **JUnit 5** - 测试框架（`@Test`, `@BeforeEach`, `@DisplayName`）
- **Mockito** - Mock框架（`@Mock`, `@InjectMocks`, `when()`, `verify()`）
- **AssertJ** - 流式断言库（`assertThat()`）
- **Spring Test** - Spring集成测试（`@SpringBootTest`, `@WebMvcTest`）
- **MockMvc** - HTTP接口测试

### 2. 依赖配置
Spring Boot Starter Test已包含所有必要依赖：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

## 二、测试分层策略

### 1. Service层单元测试
**目标**：测试业务逻辑，隔离外部依赖

**特点**：
- 使用 `@ExtendWith(MockitoExtension.class)`
- Mock所有依赖（Dao、Convert等）
- 快速执行，不依赖Spring容器

**示例**：
```java
@ExtendWith(MockitoExtension.class)
class TagServiceTest {
    @Mock
    private TagDao tagDao;

    @Mock
    private TagConvert tagConvert;

    @InjectMocks
    private TagServiceImpl tagService;
}
```

### 2. Controller层集成测试
**目标**：测试HTTP接口，验证请求/响应

**特点**：
- 使用 `@WebMvcTest(XxxController.class)` - 只加载Web层
- 使用 `MockMvc` 模拟HTTP请求
- Mock Service层依赖

**示例**：
```java
@WebMvcTest(TagController.class)
class TagControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private TagService tagService;

    @Test
    void getTag_shouldReturnTag() throws Exception {
        mockMvc.perform(get("/tag/1"))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.data.id").value(1));
    }
}
```

### 3. Repository层测试（可选）
**目标**：测试数据库交互

**特点**：
- 使用 `@DataJpaTest` 或 H2内存数据库
- 测试自定义SQL、复杂查询
- 本项目使用MyBatis-Plus，通常不需要单独测试

## 三、CRUD操作测试模式

### 1. 查询（Query/Get）测试

#### Service层测试
```java
@Test
@DisplayName("查询成功 - 根据ID获取数据")
void getById_shouldReturnData_whenExists() {
    // Given: 准备mock数据
    when(dao.getById(1L)).thenReturn(mockEntity);
    when(convert.toDTO(mockEntity)).thenReturn(mockDTO);

    // When: 执行查询
    DTO result = service.getById(1L);

    // Then: 验证结果
    assertThat(result).isNotNull();
    assertThat(result.getId()).isEqualTo(1L);

    // 验证方法调用
    verify(dao, times(1)).getById(1L);
    verify(convert, times(1)).toDTO(mockEntity);
}

@Test
@DisplayName("查询失败 - 数据不存在时返回null")
void getById_shouldReturnNull_whenNotExists() {
    when(dao.getById(999L)).thenReturn(null);

    DTO result = service.getById(999L);

    assertThat(result).isNull();
}
```

#### Controller层测试
```java
@Test
@DisplayName("GET /xxx/{id} - 查询成功")
void get_shouldReturn200() throws Exception {
    when(service.getById(1L)).thenReturn(mockDTO);

    mockMvc.perform(get("/xxx/1"))
           .andExpect(status().isOk())
           .andExpect(jsonPath("$.code").value(200))
           .andExpect(jsonPath("$.data.id").value(1));
}

@Test
@DisplayName("GET /xxx/{id} - 查询失败，返回404")
void get_shouldReturn404_whenNotExists() throws Exception {
    when(service.getById(999L)).thenReturn(null);

    mockMvc.perform(get("/xxx/999"))
           .andExpect(status().isNotFound());
}
```

### 2. 新增（Create/Save）测试

#### Service层测试
```java
@Test
@DisplayName("新增成功 - 保存数据")
void save_shouldReturnSaved_whenSuccessful() {
    // Given
    when(convert.toEntity(inputDTO)).thenReturn(inputEntity);
    when(dao.save(inputEntity)).thenReturn(true);
    when(convert.toDTO(inputEntity)).thenReturn(savedDTO);

    // When
    DTO result = service.save(inputDTO);

    // Then
    assertThat(result).isNotNull();
    verify(dao, times(1)).save(inputEntity);
}

@Test
@DisplayName("新增验证 - 使用ArgumentCaptor验证保存的数据")
void save_shouldSaveCorrectData() {
    ArgumentCaptor<Entity> captor = ArgumentCaptor.forClass(Entity.class);
    when(dao.save(any())).thenReturn(true);

    service.save(inputDTO);

    verify(dao).save(captor.capture());
    Entity saved = captor.getValue();
    assertThat(saved.getName()).isEqualTo("期望的名称");
}
```

#### Controller层测试
```java
@Test
@DisplayName("POST /xxx/create - 新增成功")
void create_shouldReturn200() throws Exception {
    when(service.save(any())).thenReturn(savedDTO);

    mockMvc.perform(post("/xxx/create")
                   .contentType(MediaType.APPLICATION_JSON)
                   .content(objectMapper.writeValueAsString(inputDTO)))
           .andExpect(status().isOk())
           .andExpect(jsonPath("$.message").value("创建成功"));
}

@Test
@DisplayName("POST /xxx/create - 参数校验失败")
void create_shouldReturn400_whenInvalid() throws Exception {
    DTO invalidDTO = new DTO(); // 缺少必填字段

    mockMvc.perform(post("/xxx/create")
                   .contentType(MediaType.APPLICATION_JSON)
                   .content(objectMapper.writeValueAsString(invalidDTO)))
           .andExpect(status().isBadRequest());

    verify(service, never()).save(any());
}
```

### 3. 修改（Update）测试

#### Service层测试
```java
@Test
@DisplayName("修改成功 - 更新数据")
void updateById_shouldReturnUpdated_whenSuccessful() {
    // Given
    when(convert.toEntity(updateDTO)).thenReturn(updateEntity);
    when(dao.updateById(updateEntity)).thenReturn(true);
    when(convert.toDTO(updateEntity)).thenReturn(updatedDTO);

    // When
    DTO result = service.updateById(1L, updateDTO);

    // Then
    assertThat(result).isNotNull();
    assertThat(updateDTO.getId()).isEqualTo(1L); // 验证ID被设置
    verify(dao, times(1)).updateById(updateEntity);
}

@Test
@DisplayName("修改失败 - 更新失败时返回null")
void updateById_shouldReturnNull_whenFailed() {
    when(convert.toEntity(updateDTO)).thenReturn(updateEntity);
    when(dao.updateById(updateEntity)).thenReturn(false);

    DTO result = service.updateById(1L, updateDTO);

    assertThat(result).isNull();
}
```

#### Controller层测试
```java
@Test
@DisplayName("PUT /xxx/{id} - 修改成功")
void update_shouldReturn200() throws Exception {
    when(service.updateById(eq(1L), any())).thenReturn(updatedDTO);

    mockMvc.perform(put("/xxx/1")
                   .contentType(MediaType.APPLICATION_JSON)
                   .content(objectMapper.writeValueAsString(updateDTO)))
           .andExpect(status().isOk())
           .andExpect(jsonPath("$.message").value("更新成功"));
}

@Test
@DisplayName("PUT /xxx/{id} - 修改失败，数据不存在")
void update_shouldReturn404_whenNotExists() throws Exception {
    when(service.updateById(eq(999L), any())).thenReturn(null);

    mockMvc.perform(put("/xxx/999")
                   .contentType(MediaType.APPLICATION_JSON)
                   .content(objectMapper.writeValueAsString(updateDTO)))
           .andExpect(status().isNotFound());
}
```

### 4. 删除（Delete/Remove）测试

#### Service层测试
```java
@Test
@DisplayName("删除成功 - 根据ID删除")
void removeById_shouldReturnTrue_whenSuccessful() {
    when(dao.removeById(1L)).thenReturn(true);

    boolean result = service.removeById(1L);

    assertThat(result).isTrue();
    verify(dao, times(1)).removeById(1L);
}

@Test
@DisplayName("删除失败 - 数据不存在")
void removeById_shouldReturnFalse_whenNotExists() {
    when(dao.removeById(999L)).thenReturn(false);

    boolean result = service.removeById(999L);

    assertThat(result).isFalse();
}
```

#### Controller层测试
```java
@Test
@DisplayName("DELETE /xxx/{id} - 删除成功")
void delete_shouldReturn200() throws Exception {
    when(service.removeById(1L)).thenReturn(true);

    mockMvc.perform(delete("/xxx/1"))
           .andExpect(status().isOk())
           .andExpect(jsonPath("$.message").value("删除成功"));
}

@Test
@DisplayName("DELETE /xxx/{id} - 删除失败，数据不存在")
void delete_shouldReturn404_whenNotExists() throws Exception {
    when(service.removeById(999L)).thenReturn(false);

    mockMvc.perform(delete("/xxx/999"))
           .andExpect(status().isNotFound());
}
```

## 四、测试编写原则

### 1. Given-When-Then模式
```java
@Test
void testExample() {
    // Given: 准备测试数据和mock行为
    when(dao.getById(1L)).thenReturn(entity);

    // When: 执行被测试的方法
    DTO result = service.getById(1L);

    // Then: 验证结果和交互
    assertThat(result).isNotNull();
    verify(dao, times(1)).getById(1L);
}
```

### 2. 测试命名规范
- 方法名：`methodName_shouldExpectedBehavior_whenCondition`
- 示例：`save_shouldReturnSaved_whenDataValid`
- 使用 `@DisplayName` 提供中文描述

### 3. 测试覆盖范围
每个方法至少测试：
1. **正常路径** - 成功场景
2. **异常路径** - 失败场景（数据不存在、参数非法等）
3. **边界条件** - null值、空列表、极端值
4. **业务规则** - 特定业务逻辑验证

### 4. Mock和Verify
```java
// Mock行为
when(dao.getById(1L)).thenReturn(entity);
when(dao.save(any())).thenReturn(true);
when(dao.query()).thenThrow(new RuntimeException());

// 验证调用
verify(dao, times(1)).getById(1L);  // 调用1次
verify(dao, never()).save(any());    // 从未调用
verify(dao, atLeast(1)).query();     // 至少1次
```

### 5. 断言最佳实践
使用AssertJ流式断言：
```java
// 基本断言
assertThat(result).isNotNull();
assertThat(result.getId()).isEqualTo(1L);
assertThat(result.getName()).isEqualTo("测试");

// 集合断言
assertThat(list).isNotEmpty();
assertThat(list).hasSize(3);
assertThat(list).contains(item1, item2);

// 异常断言
assertThatThrownBy(() -> service.method())
    .isInstanceOf(IllegalArgumentException.class)
    .hasMessage("错误信息");
```

## 五、运行测试

### 1. 命令行运行
```bash
# 运行所有测试
./mvnw test

# 运行单个测试类
./mvnw test -Dtest=TagServiceTest

# 运行单个测试方法
./mvnw test -Dtest=TagServiceTest#getById_shouldReturnTag_whenTagExists

# 跳过测试
./mvnw clean package -DskipTests
```

### 2. 查看测试报告
测试报告位置：`target/surefire-reports/`

### 3. 测试覆盖率（可选）
添加JaCoCo插件到pom.xml：
```xml
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.11</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

运行：
```bash
./mvnw clean test jacoco:report
```

查看报告：`target/site/jacoco/index.html`

## 六、常见测试场景

### 1. 分页查询测试
```java
@Test
void page_shouldReturnPagedResult() {
    Page<Entity> page = new Page<>(1, 10);
    page.setRecords(Arrays.asList(entity1, entity2));
    page.setTotal(2);

    when(dao.page(any(), any())).thenReturn(page);

    PageResult<DTO> result = service.page(pageReq);

    assertThat(result.getRecords()).hasSize(2);
    assertThat(result.getTotal()).isEqualTo(2);
}
```

### 2. 批量操作测试
```java
@Test
void batchSave_shouldSaveAll() {
    List<Entity> entities = Arrays.asList(e1, e2, e3);
    when(dao.saveBatch(entities)).thenReturn(true);

    boolean result = service.batchSave(dtoList);

    assertThat(result).isTrue();
    verify(dao).saveBatch(argThat(list -> list.size() == 3));
}
```

### 3. 事务测试
```java
@Test
void transactionalMethod_shouldRollback_whenException() {
    when(dao1.save(any())).thenReturn(true);
    when(dao2.save(any())).thenThrow(new RuntimeException());

    assertThatThrownBy(() -> service.transactionalMethod())
        .isInstanceOf(RuntimeException.class);

    // 验证回滚行为（需要集成测试）
}
```

### 4. 参数校验测试
```java
@Test
void save_shouldThrowException_whenNameIsNull() {
    DTO dto = new DTO();
    dto.setName(null);

    assertThatThrownBy(() -> service.save(dto))
        .isInstanceOf(IllegalArgumentException.class);
}
```

## 七、测试数据管理

### 1. 使用@BeforeEach准备数据
```java
@BeforeEach
void setUp() {
    mockEntity = new Entity();
    mockEntity.setId(1L);
    mockEntity.setName("测试");

    mockDTO = new DTO();
    mockDTO.setId(1L);
    mockDTO.setName("测试");
}
```

### 2. 测试数据工厂（可选）
```java
public class TestDataFactory {
    public static Tag createTag(Long id, String name) {
        Tag tag = new Tag();
        tag.setId(id);
        tag.setName(name);
        return tag;
    }
}
```

## 八、注意事项

1. **测试独立性**：每个测试应该独立，不依赖其他测试
2. **Mock最小化**：只mock必要的依赖，避免过度mock
3. **测试可读性**：使用清晰的命名和@DisplayName
4. **避免逻辑**：测试代码应该简单，避免复杂逻辑
5. **测试维护**：代码修改时同步更新测试
6. **快速执行**：单元测试应该快速（毫秒级）

## 九、示例代码位置

- Service层测试：`src/test/java/com/dzy/river/chart/luo/writ/service/TagServiceTest.java`
- Controller层测试：`src/test/java/com/dzy/river/chart/luo/writ/controller/TagControllerTest.java`

参考这两个示例，为其他Service和Controller编写测试。
